<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Penghitung Harga Likuidasi</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>

  <h2>Penghitung Harga Likuidasi (Long / Short)</h2>

  <label for="mode">Tipe Mode:</label>
  <select id="mode">
    <option value="isolated">Isolated</option>
    <option value="cross">Cross</option>
  </select>

  <label for="direction">Arah Posisi:</label>
  <select id="direction">
    <option value="long">Long</option>
    <option value="short">Short</option>
  </select>

  <label for="leverage">Leverage:</label>
  <input type="number" id="leverage" step="0.0001" />

  <label for="margin">Margin (USDT):</label>
  <input type="number" id="margin" step="0.0001" />

  <label for="leveragedMargin">Leveraged Margin:</label>
  <input type="number" id="leveragedMargin" step="0.0001" />

  <label for="entryPrice">Entry Price:</label>
  <input type="number" id="entryPrice" step="0.0001" />

  <label for="positionSize">Ukuran Posisi:</label>
  <input type="number" id="positionSize" step="0.0001" />

  <div id="crossOnly" style="display:none;">
    <label for="unusedMargin">Unused Margin (Cross only):</label>
    <input type="number" id="unusedMargin" step="0.0001" />
  </div>

  <button onclick="calculateLiquidation()">Hitung Harga Likuidasi</button>

  <div id="result"></div>

  <script>
  let formulas = {};
  let isUpdating = false;

  fetch('formula.json')
    .then(res => res.json())
    .then(json => formulas = json);

  document.getElementById('mode').addEventListener('change', () => {
    document.getElementById('crossOnly').style.display =
      document.getElementById('mode').value === 'cross' ? 'block' : 'none';
  });

  const inputs = ['leverage', 'margin', 'leveragedMargin', 'entryPrice', 'positionSize'];
  inputs.forEach(id => {
    document.getElementById(id).addEventListener('input', () => recalculate());
  });

  function get(id) {
    return parseFloat(document.getElementById(id).value) || 0;
  }

  function set(id, value) {
    const el = document.getElementById(id);
    const val = value ? value.toFixed(6).replace(/\.?0+$/, '') : '';
    if (el.value !== val && !el.matches(':focus')) {
      el.value = val;
    }
  }

  function evaluateFormula(formula, vars) {
    try {
      return new Function(...Object.keys(vars), `return ${formula};`)(...Object.values(vars));
    } catch (e) {
      return 0;
    }
  }

  function recalculate() {
    if (isUpdating) return;
    isUpdating = true;

    const values = {
      leverage: get('leverage'),
      margin: get('margin'),
      leveragedMargin: get('leveragedMargin'),
      entryPrice: get('entryPrice'),
      positionSize: get('positionSize')
    };

    // STEP 1: Leverage + Margin → Leveraged Margin
    if (values.leverage > 0 && values.margin > 0) {
      values.leveragedMargin = evaluateFormula(formulas.leveragedMargin, values);
      set('leveragedMargin', values.leveragedMargin);
    }

    // STEP 2: Leveraged Margin + Entry Price → Position Size
    if (values.leveragedMargin > 0 && values.entryPrice > 0) {
      values.positionSize = evaluateFormula(formulas.positionSize, values);
      set('positionSize', values.positionSize);
    }

    // STEP 3: Entry Price + Position Size → Leveraged Margin (jika belum ada)
    if (values.entryPrice > 0 && values.positionSize > 0 && values.leveragedMargin === 0) {
      values.leveragedMargin = evaluateFormula(formulas.leveragedMarginFromEntryAndSize, values);
      set('leveragedMargin', values.leveragedMargin);
    }

    // STEP 4: Leveraged Margin + Leverage → Margin (jika belum ada)
    if (values.leveragedMargin > 0 && values.leverage > 0 && values.margin === 0) {
      values.margin = evaluateFormula(formulas.margin, values);
      set('margin', values.margin);
    }

    // STEP 5: Leveraged Margin + Margin → Leverage (jika belum ada)
    if (values.leveragedMargin > 0 && values.margin > 0 && values.leverage === 0) {
      values.leverage = evaluateFormula(formulas.leverage, values);
      set('leverage', values.leverage);
    }

    isUpdating = false;
  }

  function calculateLiquidation() {
    const mode = document.getElementById('mode').value;
    const direction = document.getElementById('direction').value;
    const values = {
      leverage: get('leverage'),
      margin: get('margin'),
      leveragedMargin: get('leveragedMargin'),
      entryPrice: get('entryPrice'),
      positionSize: get('positionSize'),
      unusedMargin: get('unusedMargin')
    };

    if (!values.leverage || !values.margin || !values.entryPrice || !values.positionSize) {
      document.getElementById('result').textContent = "Mohon isi semua nilai yang diperlukan.";
      return;
    }

    let formulaKey = '';
    if (mode === 'isolated') {
      formulaKey = direction === 'long' ? 'liquidationPriceIsolatedLong' : 'liquidationPriceIsolatedShort';
    } else {
      formulaKey = direction === 'long' ? 'liquidationPriceCrossLong' : 'liquidationPriceCrossShort';
    }

    const result = evaluateFormula(formulas[formulaKey], values);

    document.getElementById('result').textContent =
      result <= 0
        ? "Posisi anda tidak memiliki harga Likuidasi"
        : `Harga Likuidasi (Perkiraan): ${result.toFixed(6)}`;
  }
</script>

</body>
</html>
